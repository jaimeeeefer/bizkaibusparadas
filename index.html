<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Bizkaibus en Tiempo Real - Parada</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: 'Teletext', monospace; /* Use a monospace font to mimic teletext */
      text-align: center;
      padding: 1em;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: black; /* Black background for teletext look */
      color: red; /* Red text for teletext look */
      font-size: 2.5em; /* Larger font size */
      overflow: hidden; /* Prevent scrollbars if content overflows slightly */
    }
    #stop-results {
      margin-top: 1em;
      width: 100%;
      max-width: 1750px; /* Keep max-width for larger screens */
      text-align: left;
    }
    #stop-results h2 {
      margin-top: 0;
      color: red;
      font-size: 1.2em; /* Slightly smaller for title */
      margin-bottom: 0.5em;
    }
    .bus-option {
      background-color: black; /* No background */
      border: none; /* No border */
      margin-bottom: 0.2em; /* Smaller margin between lines */
      padding: 0.2em 0.5em; /* Smaller padding */
      display: flex;
      justify-content: space-between;
      align-items: baseline; /* Align text baselines */
      cursor: default; /* Not clickable for this interface */
      height: 1.5em; /* Fixed height for each line to control spacing */
    }

    #stop-results .bus-option span {
        padding: 0; /* Remove padding */
        font-weight: bold; /* Bold like teletext */
        white-space: pre; /* Preserve whitespace for alignment */
    }

    #stop-results .bus-option .bus-option-linea {
        flex-basis: 30%; /* Adjust width for line number */
        min-width: 100px;
        text-align: left;
    }

    #stop-results .bus-option .bus-option-destino {
        flex-basis: 50%; /* Adjust width for destination */
        text-align: left; /* Align destination to the left */
        overflow: hidden; /* Hide overflow if text is too long */
        text-overflow: ellipsis; /* Add ellipsis for overflow */
        white-space: nowrap; /* Prevent wrapping */
    }
    
    #stop-results .bus-option .bus-option-time { /* New class for time */
        flex-basis: 20%; /* Adjust width for time */
        min-width: 80px;
        text-align: right; /* Align time to the right */
        font-size: 1em; /* Normal font size for time */
    }

    .delay-text-stop-list { /* This class will no longer be used for display, but kept for logic if needed */
        font-size: 0.7em; 
        font-style: normal; 
        margin-left: 5px;
        display: inline-block; 
    }
    .delay-text-stop-list.delay {
        color: yellow; 
    }
    .delay-text-stop-list.advance {
        color: lime; 
    }
    .delay-text-stop-list.on-time { 
        color: cyan; 
    }
    .loading-message {
        color: red;
        font-size: 1.2em;
        margin-top: 2em;
    }
  </style>
</head>
<body>
  <div id="stop-results">
    <h2 id="stop-title">Cargando datos de parada...</h2>
    <div id="bus-list">
      <p class="loading-message">Por favor, espere mientras se carga la información.</p>
    </div>
  </div>
  
  <script>
    const STOPS_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/stops.txt";
    const STOP_TIMES1_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/stop_times1.txt";
    const STOP_TIMES2_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/stop_times2.txt";
    const STOP_TIMES3_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/stop_times3.txt";
    const TRIPS_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/trips.txt";
    const CALENDAR_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/calendar.txt";
    const CALENDAR_DATES_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/calendar_dates.txt";

    let stopsData = new Map();
    let tripsData = new Map();
    let stopTimesData = [];
    let calendarData = new Map();
    let calendarDatesData = new Map();
    let busInfoMap = new Map(); 

    function timeToSeconds(timeStr) {
        if (!timeStr || !/^\d{2}:\d{2}:\d{2}$/.test(timeStr)) return 0;
        const parts = timeStr.split(':');
        return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
    }

    // Modified to return remaining minutes or 'Ahora'
    function secondsToRemainingTime(totalSeconds) {
        if (totalSeconds === null || isNaN(totalSeconds)) return "N/A";
        
        const now = new Date();
        const currentTotalSeconds = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
        
        let remainingSeconds = totalSeconds - currentTotalSeconds;
        
        // Handle cases where the bus might be for the next day but close to midnight
        if (remainingSeconds < -12 * 3600) { // If more than 12 hours behind, assume it's for the next day
            remainingSeconds += 24 * 3600;
        } else if (remainingSeconds > 12 * 3600 && totalSeconds < currentTotalSeconds) { // If more than 12 hours ahead, but scheduled time was earlier
            remainingSeconds -= 24 * 3600;
        }

        const remainingMinutes = Math.round(remainingSeconds / 60);

        if (remainingMinutes <= 0) {
            return "Ahora";
        } else {
            return `${remainingMinutes} min`;
        }
    }

    async function cargarDatosGTFS() {
      try {
        const resStops = await fetch(STOPS_URL);
        const textStops = await resStops.text();
        const rowsStops = textStops.trim().split("\n").map(row => row.split(","));
        
        rowsStops.slice(1).forEach(row => {
          const stop_id = row[0]?.trim();
          if (stop_id && row.length >= 6) {  
              stopsData.set(stop_id, {
                stop_name: row[2]?.trim(),
                stop_lat: parseFloat(row[4]),
                stop_lon: parseFloat(row[5]),
              });
          }
        });

        const stopTimesPromises = [
            fetch(STOP_TIMES1_URL).then(res => res.text()),
            fetch(STOP_TIMES2_URL).then(res => res.text()),
            fetch(STOP_TIMES3_URL).then(res => res.text())
        ];
        const stopTimesTexts = await Promise.all(stopTimesPromises);

        stopTimesTexts.forEach(text => {
            const rowsStopTimes = text.trim().split("\n").map(row => row.split(","));
            rowsStopTimes.slice(1).forEach(row => {
                if (row.length >= 5) {
                    stopTimesData.push({
                        trip_id: row[0]?.trim(),
                        arrival_time: row[1]?.trim(),
                        departure_time: row[2]?.trim(),
                        stop_id: row[3]?.trim(),
                        stop_sequence: parseInt(row[4]),
                    });
                }
            });
        });

        const resTrips = await fetch(TRIPS_URL);
        const textTrips = await resTrips.text();
        const rowsTrips = textTrips.trim().split("\n").map(row => row.split(","));
        rowsTrips.slice(1).forEach(row => {
          if (row.length >= 8) {
              tripsData.set(row[2]?.trim(), {
                route_id: row[0]?.trim(),
                service_id: row[1]?.trim(),
                trip_headsign: row[3]?.trim(),
                shape_id: row[7]?.trim(),
              });
          }
        });

        const resCalendar = await fetch(CALENDAR_URL);
        const textCalendar = await resCalendar.text();
        const rowsCalendar = textCalendar.trim().split("\n").map(row => row.split(","));
        rowsCalendar.slice(1).forEach(row => {
            if (row.length >= 10) {
                calendarData.set(row[0]?.trim(), {
                    monday: parseInt(row[1]),
                    tuesday: parseInt(row[2]),
                    wednesday: parseInt(row[3]),
                    thursday: parseInt(row[4]),
                    friday: parseInt(row[5]),
                    saturday: parseInt(row[6]),
                    sunday: parseInt(row[7]),
                    start_date: row[8]?.trim(),
                    end_date: row[9]?.trim()
                });
            }
        });

        const resCalendarDates = await fetch(CALENDAR_DATES_URL);
        const textCalendarDates = await resCalendarDates.text();
        const rowsCalendarDates = textCalendarDates.trim().split("\n").map(row => row.split(","));
        rowsCalendarDates.slice(1).forEach(row => {
            if (row.length >= 3) {
                const service_id = row[0]?.trim();
                const date = row[1]?.trim();
                const exception_type = parseInt(row[2]);

                if (!calendarDatesData.has(service_id)) {
                    calendarDatesData.set(service_id, new Map());
                }
                calendarDatesData.get(service_id).set(date, exception_type);
            }
        });
        console.log("Carga de datos GTFS completada.");
      } catch (e) {
        console.error("Error cargando datos GTFS:", e);
        document.getElementById('bus-list').innerHTML = `<p class="loading-message">Error cargando datos de Bizkaibus. Intente de nuevo más tarde.</p>`;
      }
    }

    function getCleanStopName(stopId) {
        const stopInfo = stopsData.get(stopId);
        if (stopInfo) {
            const name = stopInfo.stop_name;
            const regex = new RegExp(`\\s*\\(${stopId}\\)$`);
            return name.replace(regex, '');
        }
        return "Desconocida";
    }

    async function buscarBusesPorParada(stopId) {
        if (!stopId) {
            document.getElementById('bus-list').innerHTML = `<p class="loading-message">Error: No se proporcionó el código de parada en la URL (ej: ?parada=123).</p>`;
            return;
        }
        
        if (!stopsData.has(stopId)) {
            document.getElementById('bus-list').innerHTML = `<p class="loading-message">Parada ${stopId} no encontrada. Verifique el código de parada.</p>`;
            return;
        }

        const busListDiv = document.getElementById("bus-list");
        busListDiv.innerHTML = `<p class="loading-message">Cargando próximos autobuses para la parada ${stopId}...</p>`;
        document.getElementById('stop-results').style.display = 'block';
        const stopNameForTitle = getCleanStopName(stopId);
        document.getElementById('stop-title').textContent = `${stopId} ${stopNameForTitle}`;

        const now = new Date();
        const currentDayOfWeek = now.getDay(); 
        const currentYear = now.getFullYear();
        const currentMonth = (now.getMonth() + 1).toString().padStart(2, '0');
        const currentDay = now.getDate().toString().padStart(2, '0');
        const currentDate = `${currentYear}${currentMonth}${currentDay}`;
        const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

        const realTimeActivities = new Map();
        try {
            const rtResp = await fetch("https://bizkaibus.onrender.com/bizkaibus");
            const rtXmlText = await rtResp.text();
            const rtXml = new DOMParser().parseFromString(rtXmlText, "application/xml");
            const rtActivityElements = rtXml.getElementsByTagName("VehicleActivity");

            for (let act of rtActivityElements) {
                const jref = act.querySelector("VehicleJourneyRef")?.textContent.trim();
                const spRef = act.querySelector("StopPointRef")?.textContent.trim();
                const recordedAtTimeISO = act.querySelector("RecordedAtTime")?.textContent.trim();
                if (jref && spRef && recordedAtTimeISO) {
                    realTimeActivities.set(jref, {
                        stopPointRef: spRef,
                        recordedAtTimeISO: recordedAtTimeISO
                    });
                }
            }
        } catch (e) {
            console.warn("No se pudieron obtener datos en tiempo real para estimaciones en lista de paradas:", e);
        }

        const upcomingBuses = [];
        const stopTimesAtThisStop = stopTimesData.filter(st => st.stop_id === stopId);

        for (const st of stopTimesAtThisStop) {
            const trip = tripsData.get(st.trip_id);
            if (!trip) continue;

            const service = calendarData.get(trip.service_id);
            if (!service) continue;

            const serviceStartDate = parseInt(service.start_date);
            const serviceEndDate = parseInt(service.end_date);
            const currentFormattedDate = parseInt(currentDate);

            if (currentFormattedDate < serviceStartDate || currentFormattedDate > serviceEndDate) {
                continue; 
            }

            const serviceExceptions = calendarDatesData.get(trip.service_id);
            const currentException = serviceExceptions ? serviceExceptions.get(currentDate) : undefined;

            let runsToday = false;

            if (currentException === 1) { 
                runsToday = true;
            } else if (currentException === 2) { 
                runsToday = false;
            } else { 
                switch (currentDayOfWeek) {
                    case 0: runsToday = service.sunday === 1; break; 
                    case 1: runsToday = service.monday === 1; break;
                    case 2: runsToday = service.tuesday === 1; break;
                    case 3: runsToday = service.wednesday === 1; break;
                    case 4: runsToday = service.thursday === 1; break;
                    case 5: runsToday = service.friday === 1; break;
                    case 6: runsToday = service.saturday === 1; break;
                }
            }
            
            if (!runsToday) continue;

            let estimatedDepartureSeconds = timeToSeconds(st.departure_time);
            
            if (realTimeActivities.has(st.trip_id)) {
                const liveBusData = realTimeActivities.get(st.trip_id);
                const liveBusStopSchedule = stopTimesData.find(
                    rtSt => rtSt.trip_id === st.trip_id && rtSt.stop_id === liveBusData.stopPointRef
                );

                if (liveBusStopSchedule && liveBusData.recordedAtTimeISO) {
                    const scheduledTimeAtLiveBusStopSeconds = timeToSeconds(liveBusStopSchedule.arrival_time);
                    const realTimeDate = new Date(liveBusData.recordedAtTimeISO);
                    const actualTimeAtLiveBusStopStr = `${realTimeDate.getHours().toString().padStart(2, '0')}:${realTimeDate.getMinutes().toString().padStart(2, '0')}:${realTimeDate.getSeconds().toString().padStart(2, '0')}`;
                    const actualTimeAtLiveBusStopSeconds = timeToSeconds(actualTimeAtLiveBusStopStr);

                    if (scheduledTimeAtLiveBusStopSeconds > 0 && actualTimeAtLiveBusStopSeconds > 0) {
                        const delayAtLiveBusStopSeconds = actualTimeAtLiveBusStopSeconds - scheduledTimeAtLiveBusStopSeconds;
                        estimatedDepartureSeconds = timeToSeconds(st.departure_time) + delayAtLiveBusStopSeconds;
                    }
                }
            }

            const currentSeconds = timeToSeconds(currentTime);
            // Consider buses that departed recently but are still relevant, or are about to depart
            // A buffer of -5 minutes (300 seconds) is applied to display buses that might have just left
            // but whose real-time status might still be interesting.
            if (estimatedDepartureSeconds >= currentSeconds - 300) { 
                upcomingBuses.push({
                    linea: trip.route_id,
                    hora: st.departure_time, // Scheduled time
                    estimatedDepartureSeconds: estimatedDepartureSeconds,
                    estimatedRemainingTime: secondsToRemainingTime(estimatedDepartureSeconds), // Remaining time
                    destino: trip.trip_headsign,
                    trip_id: st.trip_id,
                });
            }
        }

        upcomingBuses.sort((a, b) => a.estimatedDepartureSeconds - b.estimatedDepartureSeconds);
        busListDiv.innerHTML = ""; 

        if (upcomingBuses.length > 0) {
            upcomingBuses.slice(0, 4).forEach(bus => { // Limit to 4 buses as requested
                const busOption = document.createElement("div");
                busOption.classList.add("bus-option");

                let timeDisplay = bus.estimatedRemainingTime;
                
                // Adjusting destination length to fit the teletext style
                let destination = bus.destino.substring(0, 20); // Limit destination length
                if (bus.destino.length > 20) {
                    destination += "..."; // Add ellipsis if truncated
                }

                busOption.innerHTML = `
                    <span class="bus-option-linea">${bus.linea}</span>
                    <span class="bus-option-destino">${destination}</span>
                    <span class="bus-option-time">${timeDisplay}</span>
                `;
                busListDiv.appendChild(busOption);
            });
        } else {
            busListDiv.innerHTML = `<p class="loading-message">No hay próximos autobuses programados o en tiempo real para esta parada hoy.</p>`;
        }
    }

    window.onload = async () => {
      await cargarDatosGTFS(); // Load GTFS data first

      // Get stop ID from URL query parameter
      const urlParams = new URLSearchParams(window.location.search);
      const stopId = urlParams.get('parada'); // e.g., ?parada=123

      buscarBusesPorParada(stopId);

      // Refresh data every 30 seconds
      setInterval(() => {
          buscarBusesPorParada(stopId);
      }, 30000); 
    };
  </script>
</body>
</html>
