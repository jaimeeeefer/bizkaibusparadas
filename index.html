<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Bizkaibus en Tiempo Real</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 1em;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5em;
      margin-bottom: 1em;
    }
    input {
      padding: 0.5em; font-size: 1em;
      width: 300px; max-width: 90vw; box-sizing: border-box;
    }
    button {
      padding: 0.5em 1em; font-size: 1em; cursor: pointer;
    }
    #map {
      height: 80vh;
      width: 100%; max-width: 1750px;
    }
    #stop-results {
      margin-top: 1em;
      width: 100%;
      max-width: 1750px;
      text-align: left;
    }
    #stop-results h2 {
      margin-top: 0;
    }
    .bus-option {
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      padding: 0.5em;
      margin-bottom: 0.5em;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .bus-option:hover {
      background-color: #e0e0e0;
    }
    .bus-option span {
      font-weight: bold;
    }
    #route-details {
      margin-top: 1em;
      width: 100%;
      max-width: 1750px;
      text-align: left;
      border: 1px solid #ccc;
      padding: 1em;
      box-sizing: border-box;
    }
    #route-details ul {
      list-style-type: none;
      padding: 0;
    }
    #route-details li {
      margin-bottom: 0.2em;
    }
  </style>
</head>
<body>
  <h1>Localizador de Autobuses Bizkaibus</h1>
  <div id="controls">
    <input type="text" id="linea" placeholder="Introduce nº de línea (ej: A3935 o 3935)" />
    <button onclick="buscarBusesPorLinea()">Buscar Línea</button>
    <input type="text" id="parada" placeholder="Introduce nº de parada (ej: 123)" />
    <button onclick="buscarBusesPorParada()">Buscar Parada</button>
  </div>
  <div id="stop-results">
    <h2>Próximos autobuses en la parada:</h2>
    <div id="bus-list"></div>
  </div>
  <div id="route-details" style="display: none;">
    <h2>Detalles del recorrido: <span id="route-line-name"></span></h2>
    <p>Dirección: <span id="route-headsign"></span></p>
    <ul id="route-stop-list"></ul>
  </div>
  <div id="map"></div>
  
  <script>
    // Autenticación básica por prompt
    const USUARIO = "admin";
    const CONTRASENA = "bizkaibus123";

    function autenticar() {
      const yaAutenticado = localStorage.getItem("autenticado");

        if (yaAutenticado === "true") return; // Ya autenticado, no pedir credenciales

          const u = prompt("Usuario:");
          const p = prompt("Contraseña:");

          if (u === USUARIO && p === CONTRASENA) {
            localStorage.setItem("autenticado", "true"); // Guardar que se autenticó correctamente
          } else {
            alert("Acceso denegado.");
            document.body.innerHTML = "<h1>401 No autorizado</h1>";
            throw new Error("Acceso denegado");
          }
        }
    autenticar();
  </script>
  
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // URL de tu hoja publicada como TSV
    const SHEET_TSV_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vTYeZkna4mwxp3p2azwTgAPcjeSBoUU_rhWW5gVZ7hqotNtojQOHtsjbEnnlJbrijBVwck_kWERE__6/pub?output=tsv";

    // URLs de los archivos GTFS proporcionados por el usuario
    const STOPS_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/refs/heads/main/stops.txt";
    const STOP_TIMES1_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/refs/heads/main/stop_times1.txt";
    const STOP_TIMES2_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/refs/heads/main/stop_times2.txt";
    const STOP_TIMES3_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/refs/heads/main/stop_times3.txt";
    const TRIPS_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/refs/heads/main/trips.txt";
    const CALENDAR_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/refs/heads/main/calendar.txt";
    const PARADAS_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/refs/heads/main/paradas.txt";


    let map = L.map("map").setView([43.25, -2.93], 10);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "© OpenStreetMap",
    }).addTo(map);

    let markers = [];
    let paradasMap = new Map(); // stop_id -> "stop_id - stop_name" (desde paradas.txt)
    let stopsData = new Map(); // stop_id -> { stop_name, stop_lat, stop_lon } (desde stops.txt)
    let busInfoMap = new Map(); // VehicleRef → { matricula, modelo }
    let stopTimesData = []; // Array of stop_time objects (desde stop_times1.txt, stop_times2.txt, stop_times3.txt)
    let tripsData = new Map(); // trip_id -> { route_id, service_id, trip_headsign }
    let calendarData = new Map(); // service_id -> { monday, tuesday, ... , start_date, end_date }

    // Colores para las líneas de ruta
    const COLORS = ['#FF0000', '#0000FF', '#008000', '#FFA500', '#800080', '#00FFFF', '#FF00FF', '#808080'];
    let linePolylines = []; // Para almacenar las polilíneas de las rutas

    // 1️⃣ Cargar datos GTFS
    async function cargarDatosGTFS() {
      try {
        // Cargar paradas del archivo 'paradas.txt' (formato "ID - Nombre")
        const resParadas = await fetch(PARADAS_URL);
        const textParadas = await resParadas.text();
        textParadas.split("\n").forEach(linea => {
          const t = linea.trim();
          if (!t) return;
          const partes = t.split(" - ");
          if (partes.length >= 2) paradasMap.set(partes[0], t);
        });

        // Cargar stops.txt
        console.log("Iniciando carga de stops.txt desde:", STOPS_URL); // Debugging: indica inicio
        const resStops = await fetch(STOPS_URL);
        const textStops = await resStops.text();
        console.log("Raw stops.txt content (first 200 chars):", textStops.substring(0, 200)); // Debugging: ver el inicio del contenido
        
        const rowsStops = textStops.trim().split("\n").map(row => row.split(","));
        console.log("Parsed stops rows (first 5, including header):", rowsStops.slice(0, 5)); // Debugging: ver las primeras filas parseadas
        
        rowsStops.slice(1).forEach(row => { // Saltar la cabecera
          const stop_id = row[0]?.trim(); // Asegurarse de trim() también aquí por si hay espacios
          if (stop_id && row.length >= 6) { // Asegurarse que stop_id existe y hay suficientes columnas
              stopsData.set(stop_id, {
                stop_name: row[2]?.trim(),
                stop_lat: parseFloat(row[4]),
                stop_lon: parseFloat(row[5]),
              });
          } else {
              console.warn("Skipping malformed or incomplete row in stops.txt:", row); // Debugging: alerta sobre filas problemáticas
          }
        });
        console.log("stopsData map size after loading:", stopsData.size); // Debugging: tamaño del mapa
        console.log("Example stop '1' from stopsData:", stopsData.get("1")); // Debugging: verificar una parada conocida
        console.log("Example stop '4' from stopsData:", stopsData.get("4")); // Debugging: verificar otra parada conocida

        // Cargar stop_times.txt (los tres archivos)
        const stopTimesPromises = [
            fetch(STOP_TIMES1_URL).then(res => res.text()),
            fetch(STOP_TIMES2_URL).then(res => res.text()),
            fetch(STOP_TIMES3_URL).then(res => res.text())
        ];
        const stopTimesTexts = await Promise.all(stopTimesPromises);

        stopTimesTexts.forEach(text => {
            const rowsStopTimes = text.trim().split("\n").map(row => row.split(","));
            rowsStopTimes.slice(1).forEach(row => { // Saltar la cabecera si existe
                // Asegurarse de que el array row tenga suficientes elementos antes de acceder a ellos
                if (row.length >= 5) {
                    stopTimesData.push({
                        trip_id: row[0]?.trim(),
                        arrival_time: row[1]?.trim(),
                        departure_time: row[2]?.trim(),
                        stop_id: row[3]?.trim(), // Trim stop_id aquí también
                        stop_sequence: parseInt(row[4]),
                    });
                }
            });
        });
        console.log("Total stopTimes loaded:", stopTimesData.length);


        // Cargar trips.txt
        const resTrips = await fetch(TRIPS_URL);
        const textTrips = await resTrips.text();
        const rowsTrips = textTrips.trim().split("\n").map(row => row.split(","));
        rowsTrips.slice(1).forEach(row => {
          if (row.length >= 8) { // Asegurarse de que hay suficientes columnas
              tripsData.set(row[2]?.trim(), { // trip_id
                route_id: row[0]?.trim(),
                service_id: row[1]?.trim(),
                trip_headsign: row[3]?.trim(),
                shape_id: row[7]?.trim(),
              });
          }
        });
        console.log("Total trips loaded:", tripsData.size);


        // Cargar calendar.txt
        const resCalendar = await fetch(CALENDAR_URL);
        const textCalendar = await resCalendar.text();
        const rowsCalendar = textCalendar.trim().split("\n").map(row => row.split(","));
        rowsCalendar.slice(1).forEach(row => {
            if (row.length >= 10) { // Asegurarse de que hay suficientes columnas
                calendarData.set(row[0]?.trim(), { // service_id
                    monday: parseInt(row[1]),
                    tuesday: parseInt(row[2]),
                    wednesday: parseInt(row[3]),
                    thursday: parseInt(row[4]),
                    friday: parseInt(row[5]),
                    saturday: parseInt(row[6]),
                    sunday: parseInt(row[7]),
                    start_date: row[8]?.trim(),
                    end_date: row[9]?.trim()
                });
            }
        });
        console.log("Total calendar services loaded:", calendarData.size);


      } catch (e) {
        console.error("Error cargando datos GTFS:", e);
      }
    }

    // 2️⃣ Cargar info de buses desde Google Sheet (TSV)
    async function cargarBusInfo() {
      try {
        const res = await fetch(SHEET_TSV_URL);
        const tsv = await res.text();
        const filas = tsv.trim().split("\n").map(r => r.split("\t"));
        // Asumimos: [0]=número, [1]=matrícula, [2]=modelo
        filas.slice(1).forEach(fila => {
          const num = fila[0]?.trim();
          if (num) {
            busInfoMap.set(num, {
              matricula: fila[1]?.trim() || "—",
              modelo: fila[2]?.trim() || "—",
              fecha: fila[3]?.trim() || "—"
            });
          }
        });
        console.log("Total bus info loaded:", busInfoMap.size);

      } catch (e) {
        console.error("Error cargando busInfo:", e);
      }
    }

    function extraerNumero(texto) {
      const m = texto.match(/\d+/);
      return m ? m[0] : null;
    }

    function clearMapElements() {
        markers.forEach(m => map.removeLayer(m));
        markers = [];
        linePolylines.forEach(poly => map.removeLayer(poly));
        linePolylines = [];
    }

    // 3️⃣ Función principal de búsqueda de buses por línea (existente)
    async function buscarBusesPorLinea() {
      const inputRaw = document.getElementById("linea").value.trim();
      if (!inputRaw) return alert("Introduce un número de línea válido");

      const input = inputRaw.toUpperCase();
      const inputNum = extraerNumero(inputRaw);

      clearMapElements();
      document.getElementById('stop-results').style.display = 'none';
      document.getElementById('route-details').style.display = 'none';


      try {
        const resp = await fetch("https://bizkaibus.onrender.com/bizkaibus");
        const xmlText = await resp.text();
        const xml = new DOMParser().parseFromString(xmlText, "application/xml");
        const actividades = xml.getElementsByTagName("VehicleActivity");
        let encontrados = 0;
        let bounds = new L.LatLngBounds();

        for (let act of actividades) {
          const jref = act.querySelector("VehicleJourneyRef")?.textContent.trim().toUpperCase();
          const vref = act.querySelector("VehicleRef")?.textContent.trim();
          const lat = parseFloat(act.querySelector("Latitude")?.textContent);
          const lon = parseFloat(act.querySelector("Longitude")?.textContent);
          const sp = act.querySelector("StopPointRef")?.textContent.trim();

          if (!jref || !vref || isNaN(lat) || isNaN(lon)) continue;

          // Extrae A#### y número
          const match = jref.match(/A\d{3,4}/);
          const lineaLimpia = match ? match[0] : jref;
          const lineaNum = extraerNumero(lineaLimpia);
          const coincide = (
            lineaLimpia === input ||
            (inputNum && lineaNum === inputNum)
          );
          if (!coincide) continue;

          // Nombre de parada
          let paradaTexto = "Parada desconocida";
          if (sp) {
            const numSp = extraerNumero(sp);
            if (numSp && paradasMap.has(numSp)) {
              paradaTexto = paradasMap.get(numSp);
            }
          }

          // Matrícula y modelo
          const infoBus = busInfoMap.get(vref) || { matricula: "—", modelo: "—", fecha: "—"};

          // Marcador y popup
          const marcador = L.marker([lat, lon]).addTo(map);
          marcador.bindPopup(`
            <b>Línea:</b> ${lineaLimpia}<br>
            <b>Parada:</b> ${paradaTexto}<br>
            <b>Bus:</b> ${vref}<br>
            <b>Matrícula:</b> ${infoBus.matricula}<br>
            <b>Modelo:</b> ${infoBus.modelo}<br>
            <b>Fecha matriculación:</b> ${infoBus.fecha}
          `);
          markers.push(marcador);
          bounds.extend([lat, lon]);
          encontrados++;
        }

        if (!encontrados) {
          alert("No se encontraron buses en tiempo real para esa línea.");
        } else {
            map.fitBounds(bounds, { padding: [50, 50] });
        }
      } catch (e) {
        console.error("Error en buscarBusesPorLinea:", e);
        alert("Error al descargar o procesar datos de Bizkaibus.");
      }
    }

    // 4️⃣ Nueva función para buscar buses por parada
    async function buscarBusesPorParada() {
        const stopIdInput = document.getElementById("parada").value.trim();
        console.log("Input de parada:", `"${stopIdInput}"`); // Debugging: qué valor se está usando
        if (!stopIdInput) {
            return alert("Introduce un número de parada válido.");
        }

        const stopId = stopIdInput; // El ID de parada ya es el número
        
        // **Este es el punto clave:** verificar si el stopId está en stopsData
        if (!stopsData.has(stopId)) {
            console.error(`La parada con ID "${stopId}" NO se encontró en stopsData.`); // Debugging: log detallado
            console.log("stopsData keys:", Array.from(stopsData.keys()).slice(0, 20)); // Debugging: mostrar algunas claves
            return alert("Parada no encontrada. Introduce un ID de parada válido.");
        }
        console.log(`La parada con ID "${stopId}" SE encontró en stopsData.`); // Debugging: confirmación

        clearMapElements();
        document.getElementById('route-details').style.display = 'none';

        const busListDiv = document.getElementById("bus-list");
        busListDiv.innerHTML = "Cargando próximos autobuses...";
        document.getElementById('stop-results').style.display = 'block';

        const now = new Date();
        const currentDayOfWeek = now.getDay(); // 0 (Domingo) a 6 (Sábado)
        const currentYear = now.getFullYear();
        const currentMonth = (now.getMonth() + 1).toString().padStart(2, '0');
        const currentDay = now.getDate().toString().padStart(2, '0');
        const currentDate = `${currentYear}${currentMonth}${currentDay}`; // Formato YYYYMMDD
        const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

        const upcomingBuses = [];

        // Filtrar stopTimes para la parada actual
        const stopTimesAtThisStop = stopTimesData.filter(st => st.stop_id === stopId);
        console.log(`stopTimesAtThisStop para ID ${stopId}:`, stopTimesAtThisStop.length, "entradas.");

        for (const st of stopTimesAtThisStop) {
            const trip = tripsData.get(st.trip_id);
            if (!trip) continue;

            const service = calendarData.get(trip.service_id);
            if (!service) continue;

            // Verificar si el servicio está activo hoy
            const serviceStartDate = parseInt(service.start_date);
            const serviceEndDate = parseInt(service.end_date);
            const currentFormattedDate = parseInt(currentDate);

            if (currentFormattedDate < serviceStartDate || currentFormattedDate > serviceEndDate) {
                continue; // Servicio no activo en la fecha actual
            }

            let runsToday = false;
            switch (currentDayOfWeek) {
                case 0: runsToday = service.sunday === 1; break;
                case 1: runsToday = service.monday === 1; break;
                case 2: runsToday = service.tuesday === 1; break;
                case 3: runsToday = service.wednesday === 1; break;
                case 4: runsToday = service.thursday === 1; break;
                case 5: runsToday = service.friday === 1; break;
                case 6: runsToday = service.saturday === 1; break;
            }
            if (!runsToday) continue;

            // Solo si el horario es futuro
            if (st.departure_time > currentTime) {
                upcomingBuses.push({
                    linea: trip.route_id,
                    hora: st.departure_time,
                    destino: trip.trip_headsign,
                    trip_id: st.trip_id,
                    shape_id: trip.shape_id // Guardar shape_id para dibujar la ruta
                });
            }
        }

        // Ordenar por hora
        upcomingBuses.sort((a, b) => a.hora.localeCompare(b.hora));

        busListDiv.innerHTML = "";
        if (upcomingBuses.length > 0) {
            // Mostrar la ubicación de la parada
            const stopInfo = stopsData.get(stopId);
            if (stopInfo) {
                const stopMarker = L.marker([stopInfo.stop_lat, stopInfo.stop_lon]).addTo(map);
                stopMarker.bindPopup(`<b>Parada:</b> ${stopInfo.stop_name} (${stopId})`).openPopup();
                markers.push(stopMarker);
                map.setView([stopInfo.stop_lat, stopInfo.stop_lon], 15);
            }

            upcomingBuses.slice(0, 10).forEach(bus => { // Mostrar los 10 próximos
                const busOption = document.createElement("div");
                busOption.classList.add("bus-option");
                busOption.innerHTML = `
                    <span>Línea: ${bus.linea}</span>
                    <span>Hora: ${bus.hora}</span>
                    <span>Destino: ${bus.destino}</span>
                `;
                busOption.onclick = () => mostrarRecorrido(bus.trip_id, bus.shape_id);
                busListDiv.appendChild(busOption);
            });
        } else {
            busListDiv.innerHTML = "<p>No hay próximos autobuses programados para esta parada hoy.</p>";
        }
    }

    // 5️⃣ Función para mostrar el recorrido y horarios de un bus específico
    async function mostrarRecorrido(tripId, shapeId) {
        clearMapElements(); // Limpiar marcadores y polilíneas anteriores
        document.getElementById('stop-results').style.display = 'none'; // Ocultar lista de próximos buses
        document.getElementById('route-details').style.display = 'block';

        const trip = tripsData.get(tripId);
        if (!trip) {
            alert("Información del viaje no encontrada.");
            return;
        }

        document.getElementById('route-line-name').textContent = trip.route_id;
        document.getElementById('route-headsign').textContent = trip.trip_headsign;
        const routeStopList = document.getElementById('route-stop-list');
        routeStopList.innerHTML = "";

        // Obtener todas las paradas de este trip_id ordenadas por secuencia
        const stopsOnRoute = stopTimesData
            .filter(st => st.trip_id === tripId)
            .sort((a, b) => a.stop_sequence - b.stop_sequence);

        let bounds = new L.LatLngBounds();
        let polylinePoints = [];

        for (const st of stopsOnRoute) {
            const stopInfo = stopsData.get(st.stop_id);
            if (stopInfo) {
                const li = document.createElement("li");
                li.innerHTML = `<b>${st.arrival_time}</b> - ${stopInfo.stop_name} (${st.stop_id})`;
                routeStopList.appendChild(li);

                // Añadir marcador a cada parada de la ruta
                const marker = L.marker([stopInfo.stop_lat, stopInfo.stop_lon]).addTo(map);
                marker.bindPopup(`
                    <b>Parada:</b> ${stopInfo.stop_name}<br>
                    <b>ID:</b> ${stopInfo.stop_id}<br>
                    <b>Hora de llegada:</b> ${st.arrival_time}<br>
                    <b>Hora de salida:</b> ${st.departure_time}
                `);
                markers.push(marker);
                bounds.extend([stopInfo.stop_lat, stopInfo.stop_lon]);
                polylinePoints.push([stopInfo.stop_lat, stopInfo.stop_lon]);
            }
        }

        // Dibujar la polilínea de la ruta
        if (polylinePoints.length > 0) {
            const color = COLORS[Math.floor(Math.random() * COLORS.length)]; // Color aleatorio
            const polyline = L.polyline(polylinePoints, { color: color, weight: 5, opacity: 0.7 }).addTo(map);
            linePolylines.push(polyline);
            map.fitBounds(bounds, { padding: [50, 50] });
        } else {
            alert("No se encontraron paradas para este recorrido.");
        }
    }


    // 6️⃣ Inicialización al cargar la página
    window.onload = async () => {
      await Promise.all([cargarParadas(), cargarBusInfo(), cargarDatosGTFS()]);
      document.getElementById('stop-results').style.display = 'none'; // Ocultar al inicio
      document.getElementById('route-details').style.display = 'none'; // Ocultar al inicio
    };
  </script>
</body>
</html>
